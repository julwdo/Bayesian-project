curve(dgamma(x, shape = gamma_shape, rate = gamma_rate), col = "blue", lwd = 2, add = TRUE)
curve(dlnorm(x, meanlog = mu_ln, sdlog = sqrt(sigma2_ln)), col = "green", lwd = 2, add = TRUE)
curve(dnorm(x, mean = normal_mean, sd = normal_sd), col = "red", lwd = 2, add = TRUE)
legend("topright", legend = c("Gamma", "Lognormal", "Normal"),
col = c("blue", "green", "red"), lwd = 2)
# Summary statistics
median(aggregate_claims_pois_lognorm)
quantile(aggregate_claims_pois_lognorm, probs = c(0.90, 0.95, 0.99))
max(aggregate_claims_pois_lognorm)
model_code_nb_lognorm <- "
model {
for (i in 1:N_y) {
y[i] ~ dlnorm(mu_lognorm, tau_lognorm)
}
for (i in 1:N_n) {
n[i] ~ dnegbin(p_nb, r_nb)
}
# Priors for Lognormal part
mu_lognorm ~ dnorm(0, 1.0E-8)
sigma_lognorm ~ dgamma(1, 0.0001)
tau_lognorm <- 1 / pow(sigma_lognorm, 2)
# Priors for Negative Binomial part
p_nb ~ dbeta(1, 1)
r_nb ~ dgamma(0.01, 0.01)
}
"
# MLE estimates for initialization
log_y <- log(itamtplcost_input$y)
mu_hat_lognorm <- mean(log_y)
sigma_hat_lognorm <- sd(log_y)
x_bar_n <- mean(itamtplcost_input$n)
var_n <- var(itamtplcost_input$n)
r_hat_nb <- x_bar_n^2 / (var_n - x_bar_n)
p_hat_nb <- r_hat_nb / (r_hat_nb + x_bar_n)
# Initial values for the model
inits_nb_lognorm <- list(
list(mu_lognorm = 0.01, sigma_lognorm = 0.5, p_nb = 0.2, r_nb = 5, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 111),
list(mu_lognorm = 2, sigma_lognorm = 1.5, p_nb = 0.5, r_nb = 10, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 222),
list(mu_lognorm = mu_hat_lognorm, sigma_lognorm = sigma_hat_lognorm, p_nb = p_hat_nb, r_nb = r_hat_nb, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 789)
)
# ---------------------------------------------------
# RUN JAGS MODEL
# ---------------------------------------------------
jags_model_nb_lognorm <- jags.model(
textConnection(model_code_nb_lognorm),
data = itamtplcost_input,
inits = inits_nb_lognorm,
n.chains = 3,
n.adapt = 1000
)
samples_nb_lognorm <- coda.samples(
jags_model_nb_lognorm,
variable.names = c("mu_lognorm", "tau_lognorm", "r_nb", "p_nb"),
n.iter = 30000
)
# Diagnostics & summaries
params <- c("mu_lognorm", "tau_lognorm", "r_nb", "p_nb")
# Gelman-Rubin diagnostics
for (param in params) {
gelman.plot(samples_nb_lognorm[, param], xlab = "", ylab = "")
}
gamma_shape
gamma_rate
mu_hat_lognorm
sigma_hat_lognorm
# MLE estimates for initialization
log_y <- log(itamtplcost_input$y)
mu_hat_lognorm <- mean(log_y)
sigma_hat_lognorm <- sd(log_y)
x_bar_n <- mean(itamtplcost_input$n)
var_n <- var(itamtplcost_input$n)
r_hat_nb <- x_bar_n^2 / (var_n - x_bar_n)
p_hat_nb <- r_hat_nb / (r_hat_nb + x_bar_n)
mu_hat_lognorm
sigma_hat_lognorm
r_hat_nb
p_hat_nb
# ---------------------------------------------------
# RUN JAGS MODEL
# ---------------------------------------------------
jags_model_nb_lognorm <- jags.model(
textConnection(model_code_nb_lognorm),
data = itamtplcost_input,
inits = inits_nb_lognorm,
n.chains = 3,
n.adapt = 20000
)
samples_nb_lognorm <- coda.samples(
jags_model_nb_lognorm,
variable.names = c("mu_lognorm", "tau_lognorm", "r_nb", "p_nb"),
n.iter = 30000
)
# Autocorrelation diagnostics
autocorr.diag(samples_nb_lognorm[, "mu_lognorm"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "tau_lognorm"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "r_nb"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "p_nb"], lags = 1:10)
# ---------------------------------------------------
# RUN JAGS MODEL
# ---------------------------------------------------
jags_model_nb_lognorm <- jags.model(
textConnection(model_code_nb_lognorm),
data = itamtplcost_input,
inits = inits_nb_lognorm,
n.chains = 3,
n.adapt = 20000
)
samples_nb_lognorm <- coda.samples(
jags_model_nb_lognorm,
variable.names = c("mu_lognorm", "tau_lognorm", "r_nb", "p_nb"),
n.iter = 3000000,
thin = 100
)
# Autocorrelation diagnostics
autocorr.diag(samples_nb_lognorm[, "mu_lognorm"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "tau_lognorm"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "r_nb"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "p_nb"], lags = 1:10)
# Traceplots
traceplot(samples_nb_lognorm[, params], main="", xlab="")
# ---------------------------------------------------
# RUN JAGS MODEL
# ---------------------------------------------------
jags_model_nb_lognorm <- jags.model(
textConnection(model_code_nb_lognorm),
data = itamtplcost_input,
inits = inits_nb_lognorm,
n.chains = 3,
n.adapt = 20000
)
samples_nb_lognorm <- coda.samples(
jags_model_nb_lognorm,
variable.names = c("mu_lognorm", "tau_lognorm", "r_nb", "p_nb"),
n.iter = 6000000,
thin = 200
)
# Autocorrelation diagnostics
autocorr.diag(samples_nb_lognorm[, "mu_lognorm"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "tau_lognorm"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "r_nb"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "p_nb"], lags = 1:10)
# Traceplots
traceplot(samples_nb_lognorm[, params], main="", xlab="")
View(itamtplcost)
# Posterior summary
summary(samples_nb_lognorm)
# ---------------------------------------------------
# RUN JAGS MODEL
# ---------------------------------------------------
jags_model_nb_lognorm <- jags.model(
textConnection(model_code_nb_lognorm),
data = itamtplcost_input,
inits = inits_nb_lognorm,
n.chains = 3,
n.adapt = 20000
)
samples_nb_lognorm <- coda.samples(
jags_model_nb_lognorm,
variable.names = c("mu_lognorm", "tau_lognorm", "r_nb", "p_nb"),
n.iter = 3000000,
thin = 100
)
gelman.diag(samples_nb_lognorm, autoburnin = FALSE)
# Autocorrelation diagnostics
autocorr.diag(samples_nb_lognorm[, "mu_lognorm"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "tau_lognorm"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "r_nb"], lags = 1:10)
autocorr.diag(samples_nb_lognorm[, "p_nb"], lags = 1:10)
# Traceplots
traceplot(samples_nb_lognorm[, params], main="", xlab="")
# Posterior summary
summary(samples_nb_lognorm)
# Density plots
plot(density(as.matrix(samples_nb_lognorm[, "mu_lognorm"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_nb_lognorm[, "tau_lognorm"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_nb_lognorm[, "r_nb"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_nb_lognorm[, "p_nb"])), main="", xlab="", ylab="")
# Lognormal expected value calculation
posterior_nb_lognorm <- as.matrix(samples_nb_lognorm)
expected_y_lognorm <- lognormal_ev(posterior_nb_lognorm[, "mu_lognorm"], posterior_nb_lognorm[, "tau_lognorm"])
mean(expected_y_lognorm)
sd(expected_y_lognorm)
quantile(expected_y_lognorm, c(0.025, 0.5, 0.975), na.rm = TRUE)
plot(density(expected_y_lognorm, na.rm=TRUE), main="", xlab="", ylab="")
# ---------------------------------------------------
# PLOT: Empirical vs Posterior Lognormal CDF
# ---------------------------------------------------
y_obs <- itamtplcost_input$y
mu_post_mean <- mean(posterior_nb_lognorm[, "mu_lognorm"])
sigma_post_mean <- mean(1 / sqrt(posterior_nb_lognorm[, "tau_lognorm"]))
plot(
ecdf(y_obs),
col = "blue",
main = "Empirical vs Posterior Lognormal CDF",
xlab = "y values",
ylab = "CDF",
lwd = 2
)
x_vals <- seq(min(y_obs), max(y_obs), length.out = 500)
lines(x_vals, lognormal_cdf(x_vals, mu_post_mean, sigma_post_mean), col = "red", lwd = 2, lty = 2)
legend("bottomright",
legend = c("Empirical CDF", sprintf("Lognormal(%.3f, %.3f) CDF", mu_post_mean, sigma_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# ---------------------------------------------------
# PLOT 2: EMPIRICAL VS POSTERIOR NEGATIVE BINOMIAL CDF
# ---------------------------------------------------
n <- itamtplcost_input$n
r_post_mean <- mean(posterior_nb_lognorm[, "r_nb"])
p_post_mean <- mean(posterior_nb_lognorm[, "p_nb"])
# Plot empirical CDF for Negative Binomial counts
plot(
ecdf(n),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2,
xlim = c(min(n), max(n) + 3)  # extend x-axis for visibility
)
# Overlay theoretical Negative Binomial CDF
x_vals <- min(n):(max(n) + 3)
lines(x_vals, pnbinom(x_vals, r_post_mean, p_post_mean),
col = "red", lwd = 2, lty = 2, type = "s")  # 's' for step
legend("bottomright",
legend = c("Empirical CDF", sprintf("NegBinomial(%.3f, %.3f) CDF", r_post_mean, p_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# ---------------------------------------------------
# Posterior Predictive Sampling for y
# ---------------------------------------------------
lognorm_predictions <- numeric(1000)
uniform_samples <- runif(1000)
mu_posterior <- posterior_nb_lognorm[, "mu_lognorm"]
sigma_posterior <- 1 / sqrt(posterior_nb_lognorm[, "tau_lognorm"])
for (i in seq_along(uniform_samples)) {
U <- uniform_samples[i]
normal_samples <- qnorm(U, mean = mu_posterior, sd = sigma_posterior)
lognorm_samples <- exp(normal_samples)
lognorm_predictions[i] <- mean(lognorm_samples)
}
plot(density(lognorm_predictions, na.rm = TRUE), main = "", xlab = "", ylab = "")
# ---------------------------------------------------
# PREDICTIONS: Negative Binomial-Lognormal Distribution
# ---------------------------------------------------
set.seed(123)
# Function to simulate Negative Binomial samples
negbin <- function(r, p, U) {
k <- 0
prob <- dnbinom(k, size = r, prob = p)
F <- prob
while (U > F) {
k <- k + 1
prob <- dnbinom(k, size = r, prob = p)
F <- F + prob
}
return(k)
}
# Simulation parameters
n_sim <- 1000
r_posterior <- posterior_nb_lognorm[, "r_nb"]
p_posterior <- posterior_nb_lognorm[, "p_nb"]
# Simulate number of claims
uniform_nb <- runif(n_sim)
nb_results <- numeric(n_sim)
for (i in seq_along(uniform_nb)) {
U <- uniform_nb[i]
cat("Simulation", i, "\n")
nb_samples <- numeric(length(r_posterior))
for (j in seq_along(r_posterior)) {
nb_samples[j] <- negbin(r = r_posterior[j], p = p_posterior[j], U = U)
}
nb_results[i] <- round(mean(nb_samples))
}
# Compare empirical vs simulated claim counts
summary(itamtplcost_input$n) # Empirical
summary(nb_results) # Fitted
# Simulate aggregate claims
aggregate_claims_nb_lognorm <- numeric(length(nb_results))
for (i in seq_along(nb_results)) {
n <- nb_results[i]
cat("Simulation", i, "\n")
lognorm_samples <- numeric(n)
uniform_lognorm <- runif(n)
for (j in seq_along(uniform_lognorm)) {
U <- uniform_lognorm[j]
normal_samples <- qnorm(U, mean = mu_posterior, sd = sigma_posterior)
lognorm_samples[j] <- mean(exp(normal_samples))
}
aggregate_claims_nb_lognorm[i] <- sum(lognorm_samples)
}
# Compare to empirical aggregate claim distribution
summary(help$sum) # Empirical
summary(aggregate_claims_nb_lognorm) # Fitted
# Estimate distribution parameters via moment matching
mean_S <- mean(aggregate_claims_nb_lognorm)
var_S <- var(aggregate_claims_nb_lognorm)
gamma_shape <- mean_S^2 / var_S
gamma_rate <- mean_S / var_S
sigma2_ln <- log(1 + var_S / mean_S^2)
mu_ln <- log(mean_S) - sigma2_ln / 2
normal_mean <- mean_S
normal_sd <- sqrt(var_S)
# Define support for density plots
x_vals <- seq(min(aggregate_claims_nb_lognorm), max(aggregate_claims_nb_lognorm), length.out = 1000)
gamma_densities <- dgamma(x_vals, shape = gamma_shape, rate = gamma_rate)
lognorm_densities <- dlnorm(x_vals, meanlog = mu_ln, sdlog = sqrt(sigma2_ln))
normal_densities <- dnorm(x_vals, mean = normal_mean, sd = normal_sd)
hist_density <- hist(aggregate_claims_nb_lognorm, plot = FALSE, probability = TRUE)$density
max_y <- max(gamma_densities, lognorm_densities, normal_densities, hist_density)
# Plotting
hist(aggregate_claims_nb_lognorm, probability = TRUE, breaks = 100,
col = "gray90", border = "white", main = "",
xlab = "", ylab = "", ylim = c(0, max_y * 1.05))
curve(dgamma(x, shape = gamma_shape, rate = gamma_rate), col = "blue", lwd = 2, add = TRUE)
curve(dlnorm(x, meanlog = mu_ln, sdlog = sqrt(sigma2_ln)), col = "green", lwd = 2, add = TRUE)
curve(dnorm(x, mean = normal_mean, sd = normal_sd), col = "red", lwd = 2, add = TRUE)
legend("topright", legend = c("Gamma", "Lognormal", "Normal"),
col = c("blue", "green", "red"), lwd = 2)
# Summary statistics
median(aggregate_claims_nb_lognorm)
quantile(aggregate_claims_nb_lognorm, probs = c(0.90, 0.95, 0.99))
max(aggregate_claims_nb_lognorm)
# ---------------------------------------------------
# PLOT: Empirical vs Posterior Lognormal CDF
# ---------------------------------------------------
y_obs <- itamtplcost_input$y
mu_post_mean <- mean(posterior_nb_lognorm[, "mu_lognorm"])
sigma_post_mean <- mean(1 / sqrt(posterior_nb_lognorm[, "tau_lognorm"]))
plot(
ecdf(y_obs),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2
)
x_vals <- seq(min(y_obs), max(y_obs), length.out = 500)
lines(x_vals, lognormal_cdf(x_vals, mu_post_mean, sigma_post_mean), col = "red", lwd = 2, lty = 2)
legend("bottomright",
legend = c("Empirical CDF", sprintf("Lognormal(%.3f, %.3f) CDF", mu_post_mean, sigma_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# ---------------------------------------------------
# PLOT: Empirical vs Posterior Lognormal CDF
# ---------------------------------------------------
y_obs <- itamtplcost_input$y
mu_post_mean <- mean(posterior_nb_lognorm[, "mu_lognorm"])
sigma_post_mean <- mean(1 / sqrt(posterior_nb_lognorm[, "tau_lognorm"]))
tau_post_mean <- mean(posterior_pois_lognorm[, "tau_pois_lognorm"])
plot(
ecdf(y_obs),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2
)
x_vals <- seq(min(y_obs), max(y_obs), length.out = 500)
lines(x_vals, lognormal_cdf(x_vals, mu_post_mean, tau_post_mean), col = "red", lwd = 2, lty = 2)
x_vals <- seq(min(y_obs), max(y_obs), length.out = 500)
plot(
ecdf(y_obs),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2
)
x_vals <- seq(min(y_obs), max(y_obs), length.out = 500)
lines(x_vals, lognormal_cdf(x_vals, mu_post_mean, sigma_post_mean), col = "red", lwd = 2, lty = 2)
legend("bottomright",
legend = c("Empirical CDF", sprintf("Lognormal(%.3f, %.3f) CDF", mu_post_mean, tau_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# ---------------------------------------------------
# PLOT 2: EMPIRICAL VS POSTERIOR NEGATIVE BINOMIAL CDF
# ---------------------------------------------------
n <- itamtplcost_input$n
r_post_mean <- mean(posterior_nb_lognorm[, "r_nb"])
p_post_mean <- mean(posterior_nb_lognorm[, "p_nb"])
# Plot empirical CDF for Negative Binomial counts
plot(
ecdf(n),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2,
xlim = c(min(n), max(n) + 3)  # extend x-axis for visibility
)
# Overlay theoretical Negative Binomial CDF
x_vals <- min(n):(max(n) + 3)
lines(x_vals, pnbinom(x_vals, r_post_mean, p_post_mean),
col = "red", lwd = 2, lty = 2, type = "s")  # 's' for step
r_post_mean
p_post_mean
x_vals
r_post_mean
p_post_mean
min(n):(max(n) + 3)
# Plot empirical CDF for Poisson counts
plot(
ecdf(n),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2,
xlim = c(min(n), max(n) + 3)  # extend x-axis for visibility
)
# Overlay theoretical Poisson CDF
x_vals <- min(n):(max(n) + 3)
lines(x_vals, ppois(x_vals, lambda = theta_pois_lognorm_post_mean),
col = "red", lwd = 2, lty = 2, type = "s")  # 's' for step
legend("bottomright",
legend = c("Empirical CDF", "Poisson(28.628) CDF"),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Overlay theoretical Negative Binomial CDF
x_vals <- min(n):(max(n) + 6)
lines(x_vals, pnbinom(x_vals, r_post_mean, p_post_mean),
col = "red", lwd = 2, lty = 2, type = "s")  # 's' for step
legend("bottomright",
legend = c("Empirical CDF", sprintf("NegBinomial(%.3f, %.3f) CDF", r_post_mean, p_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Plot empirical CDF for Negative Binomial counts
plot(
ecdf(n),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2,
xlim = c(min(n), max(n) + 3)  # extend x-axis for visibility
)
# Overlay theoretical Negative Binomial CDF
x_vals <- min(n):(max(n) + 6)
lines(x_vals, pnbinom(x_vals, r_post_mean, p_post_mean),
col = "red", lwd = 2, lty = 2, type = "s")  # 's' for step
legend("bottomright",
legend = c("Empirical CDF", sprintf("NegBinomial(%.3f, %.3f) CDF", r_post_mean, p_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Overlay theoretical Negative Binomial CDF
x_vals <- min(n):(max(n) + 9)
lines(x_vals, pnbinom(x_vals, r_post_mean, p_post_mean),
col = "red", lwd = 2, lty = 2, type = "s")  # 's' for step
legend("bottomright",
legend = c("Empirical CDF", sprintf("NegBinomial(%.3f, %.3f) CDF", r_post_mean, p_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Plot empirical CDF for Negative Binomial counts
plot(
ecdf(n),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2,
xlim = c(min(n), max(n) + 3)  # extend x-axis for visibility
)
# Overlay theoretical Negative Binomial CDF
x_vals <- min(n):(max(n) + 9)
lines(x_vals, pnbinom(x_vals, r_post_mean, p_post_mean),
col = "red", lwd = 2, lty = 2, type = "s")  # 's' for step
legend("bottomright",
legend = c("Empirical CDF", sprintf("NegBinomial(%.3f, %.3f) CDF", r_post_mean, p_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Plot empirical CDF for Negative Binomial counts
plot(
ecdf(n),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2,
xlim = c(min(n), max(n) + 3)  # extend x-axis for visibility
)
# Overlay theoretical Negative Binomial CDF
x_vals <- min(n):(max(n) + 3)
lines(x_vals, pnbinom(x_vals, r_post_mean, p_post_mean),
col = "red", lwd = 2, lty = 2, type = "s")  # 's' for step
legend("bottomright",
legend = c("Empirical CDF", sprintf("NegBinomial(%.3f, %.3f) CDF", r_post_mean, p_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# Posterior summary
summary(samples_nb_lognorm)
mu_hat_lognorm
sigma_hat_lognorm
r_hat_nb
p_hat_nb
mean(expected_y_lognorm)
sd(expected_y_lognorm)
quantile(expected_y_lognorm, c(0.025, 0.5, 0.975), na.rm = TRUE)
save.image("D:/Studies/Materials/Second-cycle/II year/II trimester/Bayesian Analysis/Bayesian-project/05-05.RData")
# ---------------------------------------------------
# PLOT 2: EMPIRICAL VS POSTERIOR NEGATIVE BINOMIAL CDF
# ---------------------------------------------------
n <- itamtplcost_input$n
r_post_mean <- mean(posterior_nb_lognorm[, "r_nb"])
p_post_mean <- mean(posterior_nb_lognorm[, "p_nb"])
# Plot empirical CDF for Negative Binomial counts
plot(
ecdf(n),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2,
xlim = c(min(n), max(n) + 3)  # extend x-axis for visibility
)
# Overlay theoretical Negative Binomial CDF
x_vals <- min(n):(max(n) + 3)
lines(x_vals, pnbinom(x_vals, r_post_mean, p_post_mean),
col = "red", lwd = 2, lty = 2, type = "s")  # 's' for step
legend("bottomright",
legend = c("Empirical CDF", sprintf("NB(%.3f, %.3f) CDF", r_post_mean, p_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
