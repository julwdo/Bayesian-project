for(i in 1:N_n) {
n[i] ~ dpois(theta)
}
alpha ~ dgamma(1, 0.0001)T(1, )
beta ~ dgamma(1, 0.0001)I(, min_y)
theta ~ dgamma(1, 0.0001)
}
"
# Initial values for three MCMC chains
inits_list_ITA <- list(
list(alpha = 0.00001, beta = 0.00001, theta = 0.00001, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 123),
list(alpha = 100000, beta = 1.33, theta = 100000, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 456),
list(alpha = 0.169, beta = 2.161, theta = 28.563, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 789)
)
jags_model_ITA <- jags.model(
textConnection(model_code_ITA),
data = itamtplcost_input,
inits = inits_list_ITA,
n.chains = 3,
n.adapt = 5000
)
# Initial values for three MCMC chains
inits_list_ITA <- list(
list(alpha = 1.00001, beta = 0.00001, theta = 0.00001, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 123),
list(alpha = 100000, beta = 1.33, theta = 100000, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 456),
list(alpha = 1.169, beta = 2.161, theta = 28.563, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 789)
)
jags_model_ITA <- jags.model(
textConnection(model_code_ITA),
data = itamtplcost_input,
inits = inits_list_ITA,
n.chains = 3,
n.adapt = 5000
)
# Sample from posterior
samples_ITA <- coda.samples(
jags_model_ITA,
variable.names = c("alpha", "beta", "theta"),
n.iter = 30000
)
gelman.diag(samples_ITA, autoburnin = FALSE)
plot(density(as.matrix(samples_ITA[, "alpha"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "beta"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "theta"])), main="", xlab="", ylab="")
autocorr.diag(samples_ITA[, "alpha"], lags = 1:10)
autocorr.diag(samples_ITA[, "beta"], lags = 1:10)
autocorr.diag(samples_ITA[, "theta"], lags = 1:10)
# Sample from posterior
samples_ITA <- coda.samples(
jags_model_ITA,
variable.names = c("alpha", "beta", "theta"),
n.iter = 30000,
thin = 10
)
gelman.diag(samples_ITA, autoburnin = FALSE)
autocorr.diag(samples_ITA[, "alpha"], lags = 1:10)
autocorr.diag(samples_ITA[, "beta"], lags = 1:10)
autocorr.diag(samples_ITA[, "theta"], lags = 1:10)
plot(density(as.matrix(samples_ITA[, "alpha"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "beta"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "theta"])), main="", xlab="", ylab="")
pareto_ev <- function(a, b) ifelse(a > 1, (a * b) / (a - 1), NA)
posterior <- as.matrix(samples_ITA)
expected_values <- pareto_ev(posterior[, "alpha"], posterior[, "beta"])
mean(expected_values, na.rm=TRUE)
sd(expected_values, na.rm=TRUE)
quantile(expected_values, c(0.025, 0.5, 0.975), na.rm=TRUE)
plot(density(expected_values, na.rm=TRUE), main="", xlab="", ylab="")
model_code_ITA <- "
model {
for(i in 1:N_y) {
y[i] ~ dpar(alpha, beta)
}
for(i in 1:N_n) {
n[i] ~ dpois(theta)
}
alpha ~ dgamma(1, 0.0001)I(1, )
beta ~ dgamma(1, 0.0001)I(, min_y)
theta ~ dgamma(1, 0.0001)
}
"
# Compute MLE of parameters
observed_n <- itamtplcost %>% group_by(year) %>% summarise(count=n()) %>% pull(count)
# Initial values for three MCMC chains
inits_list_ITA <- list(
list(alpha = 1.00001, beta = 0.00001, theta = 0.00001, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 123),
list(alpha = 100000, beta = 1.33, theta = 100000, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 456),
list(alpha = 1.169, beta = 2.161, theta = 28.563, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 789)
)
jags_model_ITA <- jags.model(
textConnection(model_code_ITA),
data = itamtplcost_input,
inits = inits_list_ITA,
n.chains = 3,
n.adapt = 5000
)
# Sample from posterior
samples_ITA <- coda.samples(
jags_model_ITA,
variable.names = c("alpha", "beta", "theta"),
n.iter = 30000,
thin = 10
)
gelman.diag(samples_ITA, autoburnin = FALSE)
plot(density(as.matrix(samples_ITA[, "alpha"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "beta"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "theta"])), main="", xlab="", ylab="")
autocorr.diag(samples_ITA[, "alpha"], lags = 1:10)
autocorr.diag(samples_ITA[, "beta"], lags = 1:10)
autocorr.diag(samples_ITA[, "theta"], lags = 1:10)
pareto_ev <- function(a, b) ifelse(a > 1, (a * b) / (a - 1), NA)
posterior <- as.matrix(samples_ITA)
expected_values <- pareto_ev(posterior[, "alpha"], posterior[, "beta"])
mean(expected_values, na.rm=TRUE)
sd(expected_values, na.rm=TRUE)
quantile(expected_values, c(0.025, 0.5, 0.975), na.rm=TRUE)
plot(density(expected_values, na.rm=TRUE), main="", xlab="", ylab="")
posterior_ITA <- as.matrix(samples_ITA)
n_sim <- 1000
theta_values <- posterior_ITA[, "theta"]
alpha_values <- posterior_ITA[, "alpha"]
beta_values <- posterior_ITA[, "beta"]
# Simulate Poisson samples
uniform_poisson <- runif(n_sim)
poisson_results <- numeric(n_sim)
for (i in seq_along(uniform_poisson)) {
U <- uniform_poisson[i]
poisson_samples <- numeric(length(theta_values))
for (j in seq_along(theta_values)) {
poisson_samples[j] <- pois(theta_values[j], U)
}
poisson_results[i] <- round(mean(poisson_samples))
}
# Function to simulate Poisson samples
pois <- function(lambda, U) {
p <- exp(-lambda)
F <- p
n <- 0
while (U > F) {
n <- n + 1
p <- p * lambda / n
F <- F + p
}
return(n)
}
# Simulate Poisson samples
uniform_poisson <- runif(n_sim)
poisson_results <- numeric(n_sim)
for (i in seq_along(uniform_poisson)) {
U <- uniform_poisson[i]
poisson_samples <- numeric(length(theta_values))
for (j in seq_along(theta_values)) {
poisson_samples[j] <- pois(theta_values[j], U)
}
poisson_results[i] <- round(mean(poisson_samples))
}
# Simulate aggregate claims
final_results <- numeric(length(poisson_results))
for (i in seq_along(poisson_results)) {
n <- poisson_results[i]
pareto_samples <- numeric(n)
uniform_pareto <- runif(n)
for (j in seq_along(uniform_pareto)) {
U <- uniform_pareto[j]
pareto_samples[j] <- mean(beta_values / (1 - U)^(1 / alpha_values))
}
final_results[i] <- sum(pareto_samples)
}
# Fit candidate distributions via moment matching
mean_S <- mean(final_results)
var_S <- var(final_results)
gamma_shape <- mean_S^2 / var_S
gamma_rate  <- mean_S / var_S
sigma2_ln <- log(1 + var_S / mean_S^2)
mu_ln     <- log(mean_S) - sigma2_ln / 2
normal_mean <- mean_S
normal_sd   <- sqrt(var_S)
# Define support for density plots
x_vals <- seq(min(final_results), max(final_results), length.out = 1000)
gamma_densities   <- dgamma(x_vals, shape = gamma_shape, rate = gamma_rate)
lognorm_densities <- dlnorm(x_vals, meanlog = mu_ln, sdlog = sqrt(sigma2_ln))
normal_densities  <- dnorm(x_vals, mean = normal_mean, sd = normal_sd)
hist_density <- hist(final_results, plot = FALSE, probability = TRUE)$density
max_y <- max(gamma_densities, lognorm_densities, normal_densities, hist_density)
# Plotting
hist(final_results, probability = TRUE, breaks = 100,
col = "gray90", border = "white", main = "",
xlab = "", ylab = "", ylim = c(0, max_y * 1.05))
curve(dgamma(x, shape = gamma_shape, rate = gamma_rate), col = "blue", lwd = 2, add = TRUE)
curve(dlnorm(x, meanlog = mu_ln, sdlog = sqrt(sigma2_ln)), col = "green", lwd = 2, add = TRUE)
curve(dnorm(x, mean = normal_mean, sd = normal_sd), col = "red", lwd = 2, add = TRUE)
legend("topright", legend = c("Gamma", "Lognormal", "Normal"),
col = c("blue", "green", "red"), lwd = 2)
# Summary statistics
median(final_results)
quantile(final_results, probs = c(0.90, 0.95, 0.99))
max(final_results)
# Plotting
hist(final_results, probability = TRUE, breaks = 1000,
col = "gray90", border = "white", main = "",
xlab = "", ylab = "", ylim = c(0, max_y * 1.05))
curve(dgamma(x, shape = gamma_shape, rate = gamma_rate), col = "blue", lwd = 2, add = TRUE)
curve(dlnorm(x, meanlog = mu_ln, sdlog = sqrt(sigma2_ln)), col = "green", lwd = 2, add = TRUE)
curve(dnorm(x, mean = normal_mean, sd = normal_sd), col = "red", lwd = 2, add = TRUE)
legend("topright", legend = c("Gamma", "Lognormal", "Normal"),
col = c("blue", "green", "red"), lwd = 2)
# Plotting
hist(final_results, probability = TRUE, breaks = 100,
col = "gray90", border = "white", main = "",
xlab = "", ylab = "", ylim = c(0, max_y * 1.05))
curve(dgamma(x, shape = gamma_shape, rate = gamma_rate), col = "blue", lwd = 2, add = TRUE)
curve(dlnorm(x, meanlog = mu_ln, sdlog = sqrt(sigma2_ln)), col = "green", lwd = 2, add = TRUE)
curve(dnorm(x, mean = normal_mean, sd = normal_sd), col = "red", lwd = 2, add = TRUE)
legend("topright", legend = c("Gamma", "Lognormal", "Normal"),
col = c("blue", "green", "red"), lwd = 2)
model_code_ITA <- "
model {
for(i in 1:N_y) {
y[i] ~ dpar(alpha, beta)
}
for(i in 1:N_n) {
n[i] ~ dpois(theta)
}
alpha ~ dgamma(1, 0.0001)T(1, )
beta ~ dgamma(1, 0.0001)I(, min_y)
theta ~ dgamma(1, 0.0001)
}
"
# Compute MLE of parameters
observed_n <- itamtplcost %>% group_by(year) %>% summarise(count=n()) %>% pull(count)
theta_mle <- mean(observed_n) # MLE of theta
theta_mle
observed_y <- itamtplcost$claim_amount
beta_mle <- min(observed_y) # MLE of beta
beta_mle
alpha_mle <- 1 / mean(log(observed_y / beta_mle))
alpha_mle
# Initial values for three MCMC chains
inits_list_ITA <- list(
list(alpha = 1.00001, beta = 0.00001, theta = 0.00001, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 123),
list(alpha = 100000, beta = 1.33, theta = 100000, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 456),
list(alpha = 1.169, beta = 2.161, theta = 28.563, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 789)
)
jags_model_ITA <- jags.model(
textConnection(model_code_ITA),
data = itamtplcost_input,
inits = inits_list_ITA,
n.chains = 3,
n.adapt = 5000
)
# Sample from posterior
samples_ITA <- coda.samples(
jags_model_ITA,
variable.names = c("alpha", "beta", "theta"),
n.iter = 30000,
thin = 10
)
gelman.diag(samples_ITA, autoburnin = FALSE)
plot(density(as.matrix(samples_ITA[, "alpha"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "beta"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "theta"])), main="", xlab="", ylab="")
autocorr.diag(samples_ITA[, "alpha"], lags = 1:10)
autocorr.diag(samples_ITA[, "beta"], lags = 1:10)
autocorr.diag(samples_ITA[, "theta"], lags = 1:10)
posterior_ITA <- as.matrix(samples_ITA)
n_sim <- 1000
theta_values <- posterior_ITA[, "theta"]
alpha_values <- posterior_ITA[, "alpha"]
beta_values <- posterior_ITA[, "beta"]
# Simulate Poisson samples
uniform_poisson <- runif(n_sim)
poisson_results <- numeric(n_sim)
for (i in seq_along(uniform_poisson)) {
U <- uniform_poisson[i]
poisson_samples <- numeric(length(theta_values))
for (j in seq_along(theta_values)) {
poisson_samples[j] <- pois(theta_values[j], U)
}
poisson_results[i] <- round(mean(poisson_samples))
}
# Simulate aggregate claims
final_results <- numeric(length(poisson_results))
for (i in seq_along(poisson_results)) {
n <- poisson_results[i]
pareto_samples <- numeric(n)
uniform_pareto <- runif(n)
for (j in seq_along(uniform_pareto)) {
U <- uniform_pareto[j]
pareto_samples[j] <- mean(beta_values / (1 - U)^(1 / alpha_values))
}
final_results[i] <- sum(pareto_samples)
}
# Fit candidate distributions via moment matching
mean_S <- mean(final_results)
var_S <- var(final_results)
gamma_shape <- mean_S^2 / var_S
gamma_rate  <- mean_S / var_S
sigma2_ln <- log(1 + var_S / mean_S^2)
mu_ln     <- log(mean_S) - sigma2_ln / 2
normal_mean <- mean_S
normal_sd   <- sqrt(var_S)
# Define support for density plots
x_vals <- seq(min(final_results), max(final_results), length.out = 1000)
gamma_densities   <- dgamma(x_vals, shape = gamma_shape, rate = gamma_rate)
lognorm_densities <- dlnorm(x_vals, meanlog = mu_ln, sdlog = sqrt(sigma2_ln))
normal_densities  <- dnorm(x_vals, mean = normal_mean, sd = normal_sd)
hist_density <- hist(final_results, plot = FALSE, probability = TRUE)$density
max_y <- max(gamma_densities, lognorm_densities, normal_densities, hist_density)
# Plotting
hist(final_results, probability = TRUE, breaks = 100,
col = "gray90", border = "white", main = "",
xlab = "", ylab = "", ylim = c(0, max_y * 1.05))
curve(dgamma(x, shape = gamma_shape, rate = gamma_rate), col = "blue", lwd = 2, add = TRUE)
curve(dlnorm(x, meanlog = mu_ln, sdlog = sqrt(sigma2_ln)), col = "green", lwd = 2, add = TRUE)
curve(dnorm(x, mean = normal_mean, sd = normal_sd), col = "red", lwd = 2, add = TRUE)
legend("topright", legend = c("Gamma", "Lognormal", "Normal"),
col = c("blue", "green", "red"), lwd = 2)
# Summary statistics
median(final_results)
quantile(final_results, probs = c(0.90, 0.95, 0.99))
max(final_results)
1/0.0001
1/0.001
model_code_ITA <- "
model {
for(i in 1:N_y) {
y[i] ~ dpar(alpha, beta)
}
for(i in 1:N_n) {
n[i] ~ dpois(theta)
}
alpha ~ dgamma(1, 0.001)
beta ~ dgamma(1, 0.0001)I(, min_y)
theta ~ dgamma(1, 0.0001)
}
"
# Initial values for three MCMC chains
inits_list_ITA <- list(
list(alpha = 1.00001, beta = 0.00001, theta = 0.00001, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 123),
list(alpha = 100000, beta = 1.33, theta = 100000, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 456),
list(alpha = 1.169, beta = 2.161, theta = 28.563, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 789)
)
jags_model_ITA <- jags.model(
textConnection(model_code_ITA),
data = itamtplcost_input,
inits = inits_list_ITA,
n.chains = 3,
n.adapt = 5000
)
# Sample from posterior
samples_ITA <- coda.samples(
jags_model_ITA,
variable.names = c("alpha", "beta", "theta"),
n.iter = 30000,
thin = 10
)
gelman.diag(samples_ITA, autoburnin = FALSE)
plot(density(as.matrix(samples_ITA[, "alpha"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "beta"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "theta"])), main="", xlab="", ylab="")
autocorr.diag(samples_ITA[, "alpha"], lags = 1:10)
autocorr.diag(samples_ITA[, "beta"], lags = 1:10)
autocorr.diag(samples_ITA[, "theta"], lags = 1:10)
posterior_ITA <- as.matrix(samples_ITA)
n_sim <- 1000
theta_values <- posterior_ITA[, "theta"]
alpha_values <- posterior_ITA[, "alpha"]
beta_values <- posterior_ITA[, "beta"]
# Simulate Poisson samples
uniform_poisson <- runif(n_sim)
poisson_results <- numeric(n_sim)
for (i in seq_along(uniform_poisson)) {
U <- uniform_poisson[i]
poisson_samples <- numeric(length(theta_values))
for (j in seq_along(theta_values)) {
poisson_samples[j] <- pois(theta_values[j], U)
}
poisson_results[i] <- round(mean(poisson_samples))
}
# Simulate aggregate claims
final_results <- numeric(length(poisson_results))
for (i in seq_along(poisson_results)) {
n <- poisson_results[i]
pareto_samples <- numeric(n)
uniform_pareto <- runif(n)
for (j in seq_along(uniform_pareto)) {
U <- uniform_pareto[j]
pareto_samples[j] <- mean(beta_values / (1 - U)^(1 / alpha_values))
}
final_results[i] <- sum(pareto_samples)
}
model_code_ITA <- "
model {
for(i in 1:N_y) {
y[i] ~ dpar(alpha, beta)
}
for(i in 1:N_n) {
n[i] ~ dpois(theta)
}
alpha ~ dgamma(1, 0.1)
beta ~ dgamma(1, 0.0001)I(, min_y)
theta ~ dgamma(1, 0.0001)
}
"
# Initial values for three MCMC chains
inits_list_ITA <- list(
list(alpha = 1.00001, beta = 0.00001, theta = 0.00001, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 123),
list(alpha = 100000, beta = 1.33, theta = 100000, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 456),
list(alpha = 1.169, beta = 2.161, theta = 28.563, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 789)
)
jags_model_ITA <- jags.model(
textConnection(model_code_ITA),
data = itamtplcost_input,
inits = inits_list_ITA,
n.chains = 3,
n.adapt = 5000
)
# Sample from posterior
samples_ITA <- coda.samples(
jags_model_ITA,
variable.names = c("alpha", "beta", "theta"),
n.iter = 30000,
thin = 10
)
gelman.diag(samples_ITA, autoburnin = FALSE)
plot(density(as.matrix(samples_ITA[, "alpha"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "beta"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "theta"])), main="", xlab="", ylab="")
exp(0.001^2-1)*exp(0.001^2)
model_code_ITA <- "
model {
for(i in 1:N_y) {
y[i] ~ dlnorm(mu, tau)
}
for(i in 1:N_n) {
n[i] ~ dpois(theta)
}
mu ~ dnorm(0, 1.0E-8)
tau ~ dgamma(1, 0.0001)
theta ~ dgamma(1, 0.0001)
}
"
# Initial values for three MCMC chains
inits_list_ITA <- list(
list(alpha = 1.00001, beta = 0.00001, theta = 0.00001, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 123),
list(alpha = 100000, beta = 1.33, theta = 100000, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 456),
list(alpha = 1.169, beta = 2.161, theta = 28.563, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 789)
)
jags_model_ITA <- jags.model(
textConnection(model_code_ITA),
data = itamtplcost_input,
inits = inits_list_ITA,
n.chains = 3,
n.adapt = 5000
)
# Sample from posterior
samples_ITA <- coda.samples(
jags_model_ITA,
variable.names = c("alpha", "beta", "theta"),
n.iter = 30000,
thin = 10
)
jags_model_ITA <- jags.model(
textConnection(model_code_ITA),
data = itamtplcost_input,
inits = inits_list_ITA,
n.chains = 3,
n.adapt = 5000
)
# Sample from posterior
samples_ITA <- coda.samples(
jags_model_ITA,
variable.names = c("mu", "tau", "theta"),
n.iter = 30000,
thin = 10
)
# Compute MLE of parameters
log_x <- log(itamtplcost_input$y)
mu_hat  <- mean(log_x)
var_hat <- var(log_x)
tau_hat <- 1 / var_hat
mu_hat
tau_hat
# Initial values for three MCMC chains
inits_list_ITA <- list(
list(mu = 0.00001, tau = 0.00001, theta = 0.00001, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 123),
list(mu = 100000, tau = 100000, theta = 100000, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 456),
list(mu = 6.700, tau = 1.554, theta = 28.563, .RNG.name = "base::Wichmann-Hill", .RNG.seed = 789)
)
jags_model_ITA <- jags.model(
textConnection(model_code_ITA),
data = itamtplcost_input,
inits = inits_list_ITA,
n.chains = 3,
n.adapt = 5000
)
# Sample from posterior
samples_ITA <- coda.samples(
jags_model_ITA,
variable.names = c("mu", "tau", "theta"),
n.iter = 30000,
thin = 10
)
gelman.diag(samples_ITA, autoburnin = FALSE)
plot(density(as.matrix(samples_ITA[, "alpha"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "tau"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "mu"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "tau"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_ITA[, "theta"])), main="", xlab="", ylab="")
autocorr.diag(samples_ITA[, "mu"], lags = 1:10)
autocorr.diag(samples_ITA[, "tau"], lags = 1:10)
autocorr.diag(samples_ITA[, "theta"], lags = 1:10)
