sigma_post_mean <- mean(1 / sqrt(posterior_nb_lognorm[, "tau_lognorm"]))
plot(
ecdf(y_obs),
col = "blue",
main = "Empirical vs Posterior Lognormal CDF",
xlab = "y values",
ylab = "CDF",
lwd = 2
)
x_vals <- seq(min(y_obs), max(y_obs), length.out = 500)
lines(x_vals, lognormal_cdf(x_vals, mu_post_mean, sigma_post_mean), col = "red", lwd = 2, lty = 2)
legend("bottomright",
legend = c("Empirical CDF", sprintf("Lognormal(%.3f, %.3f) CDF", mu_post_mean, sigma_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
# ---------------------------------------------------
# Posterior Predictive Sampling for y
# ---------------------------------------------------
lognorm_predictions <- numeric(1000)
uniform_samples <- runif(1000)
mu_posterior <- posterior_nb_lognorm[, "mu_lognorm"]
sigma_posterior <- 1 / sqrt(posterior_nb_lognorm[, "tau_lognorm"])
for (i in seq_along(uniform_samples)) {
U <- uniform_samples[i]
normal_samples <- qnorm(U, mean = mu_posterior, sd = sigma_posterior)
lognorm_samples <- exp(normal_samples)
lognorm_predictions[i] <- mean(lognorm_samples)
}
plot(density(lognorm_predictions, na.rm = TRUE), main = "", xlab = "", ylab = "")
# ---------------------------------------------------
# PREDICTIONS: Negative Binomial-Lognormal Distribution
# ---------------------------------------------------
set.seed(123)
# Function to simulate Negative Binomial samples
negbin <- function(r, p, U) {
k <- 0
prob <- dnbinom(k, size = r, prob = p)
F <- prob
while (U > F) {
k <- k + 1
prob <- dnbinom(k, size = r, prob = p)
F <- F + prob
}
return(k)
}
# Simulation parameters
n_sim <- 1000
r_posterior <- posterior_nb_lognorm[, "r_nb"]
p_posterior <- posterior_nb_lognorm[, "p_nb"]
# Simulate number of claims
uniform_nb <- runif(n_sim)
nb_results <- numeric(n_sim)
for (i in seq_along(uniform_nb)) {
U <- uniform_nb[i]
cat("Simulation", i, "\n")
nb_samples <- numeric(length(r_posterior))
for (j in seq_along(r_posterior)) {
nb_samples[j] <- negbin(r = r_posterior[j], p = p_posterior[j], U = U)
}
nb_results[i] <- round(mean(nb_samples))
}
# Compare empirical vs simulated claim counts
summary(itamtplcost_input$n) # Empirical
summary(nb_results) # Fitted
# Simulate aggregate claims
aggregate_claims_nb_lognorm <- numeric(length(nb_results))
for (i in seq_along(nb_results)) {
n <- nb_results[i]
lognorm_samples <- numeric(n)
uniform_lognorm <- runif(n)
for (j in seq_along(uniform_lognorm)) {
U <- uniform_lognorm[j]
normal_samples <- qnorm(U, mean = mu_posterior, sd = sigma_posterior)
lognorm_samples[j] <- mean(exp(normal_samples))
}
aggregate_claims_nb_lognorm[i] <- sum(lognorm_samples)
}
# Compare to empirical aggregate claim distribution
summary(help$sum) # Empirical
aggregate_claims_nb_lognorm
summary(aggregate_claims_nb_lognorm) # Fitted
# Compare to empirical aggregate claim distribution
summary(help$sum) # Empirical
# Compare to empirical aggregate claim distribution
help <- itamtplcost %>%
group_by(year) %>%
summarise(sum = sum(claim_amount), .groups = "drop")
# Compare to empirical aggregate claim distribution
summary(help$sum) # Empirical
summary(aggregate_claims_nb_lognorm) # Fitted
# Estimate distribution parameters via moment matching
mean_S <- mean(aggregate_claims_nb_lognorm)
var_S <- var(aggregate_claims_nb_lognorm)
gamma_shape <- mean_S^2 / var_S
gamma_rate <- mean_S / var_S
sigma2_ln <- log(1 + var_S / mean_S^2)
mu_ln <- log(mean_S) - sigma2_ln / 2
normal_mean <- mean_S
normal_sd <- sqrt(var_S)
# Define support for density plots
x_vals <- seq(min(aggregate_claims_nb_lognorm), max(aggregate_claims_nb_lognorm), length.out = 1000)
gamma_densities <- dgamma(x_vals, shape = gamma_shape, rate = gamma_rate)
lognorm_densities <- dlnorm(x_vals, meanlog = mu_ln, sdlog = sqrt(sigma2_ln))
normal_densities <- dnorm(x_vals, mean = normal_mean, sd = normal_sd)
hist_density <- hist(aggregate_claims_nb_lognorm, plot = FALSE, probability = TRUE)$density
max_y <- max(gamma_densities, lognorm_densities, normal_densities, hist_density)
# Plotting
hist(aggregate_claims_nb_lognorm, probability = TRUE, breaks = 100,
col = "gray90", border = "white", main = "",
xlab = "", ylab = "", ylim = c(0, max_y * 1.05))
curve(dgamma(x, shape = gamma_shape, rate = gamma_rate), col = "blue", lwd = 2, add = TRUE)
curve(dlnorm(x, meanlog = mu_ln, sdlog = sqrt(sigma2_ln)), col = "green", lwd = 2, add = TRUE)
curve(dnorm(x, mean = normal_mean, sd = normal_sd), col = "red", lwd = 2, add = TRUE)
legend("topright", legend = c("Gamma", "Lognormal", "Normal"),
col = c("blue", "green", "red"), lwd = 2)
# Summary statistics
median(aggregate_claims_nb_lognorm)
quantile(aggregate_claims_nb_lognorm, probs = c(0.90, 0.95, 0.99))
max(aggregate_claims_nb_lognorm)
# ===================================================
# LOAD LIBRARIES
# ===================================================
library(CASdatasets)
library(dplyr)
library(rjags)
library(coda)
# ===================================================
# RYTGAARD1990 EXAMPLE DATA
# ===================================================
rytgaard1990_input <- list(
y = c(2.495, 2.120, 2.095, 1.700, 1.650, 1.985, 1.810, 1.625,
3.215, 2.105, 1.765, 1.715, 19.180, 1.915, 1.790, 1.755),
n = c(5, 3, 4, 0, 4)
)
# Add metadata for JAGS model
rytgaard1990_input$N_y <- length(rytgaard1990_input$y)
rytgaard1990_input$N_n <- length(rytgaard1990_input$n)
rytgaard1990_input$min_y <- min(rytgaard1990_input$y)
# ===================================================
# LOAD AND PREPARE CASDATASETS DATA
# ===================================================
data(itamtplcost)
# Extract year and rename 'UltimateCost' for clarity
itamtplcost$year <- format(as.Date(itamtplcost$Date, format = "%d/%m/%Y"), "%Y")
itamtplcost <- itamtplcost %>%
rename(claim_amount = UltimateCost) %>%
select(year, claim_amount)
# Express claim_amount in millions
itamtplcost$claim_amount <- round(itamtplcost$claim_amount / 1000, 3)
itamtplcost_input <- list(
y = itamtplcost$claim_amount,
n = as.numeric(itamtplcost %>% group_by(year) %>% summarise(count=n()) %>% pull(count))
)
itamtplcost_input$N_y <- length(itamtplcost_input$y)
itamtplcost_input$N_n <- length(itamtplcost_input$n)
itamtplcost_input$min_y <- min(itamtplcost_input$y)
model_code_pois_lognorm <- "
model {
for(i in 1:N_y) {
y[i] ~ dlnorm(mu_pois_lognorm, tau_pois_lognorm)
}
for(i in 1:N_n) {
n[i] ~ dpois(theta_pois_lognorm)
}
mu_pois_lognorm ~ dnorm(0, 1.0E-8)
sigma_pois_lognorm ~ dgamma(1, 0.0001)
tau_pois_lognorm <- 1 / pow(sigma_pois_lognorm, 2)
theta_pois_lognorm ~ dgamma(1, 0.0001)
}
"
# MLE estimates for initialization
log_y <- log(itamtplcost_input$y)
mu_hat_pois_lognorm <- mean(log_y)
sigma_hat_pois_lognorm <- sd(log_y)
theta_hat_pois_lognorm <- mean(itamtplcost_input$n)
# Initial values for the model
inits_pois_lognorm <- list(
list(mu_pois_lognorm = 0.00001,
sigma_pois_lognorm = 0.00001,
theta_pois_lognorm = 0.00001,
.RNG.name = "base::Wichmann-Hill",
.RNG.seed = 123),
list(mu_pois_lognorm = 100000,
sigma_pois_lognorm = 100000,
theta_pois_lognorm = 100000,
.RNG.name = "base::Wichmann-Hill",
.RNG.seed = 456),
list(mu_pois_lognorm = mu_hat_pois_lognorm,
sigma_pois_lognorm = sigma_hat_pois_lognorm,
theta_pois_lognorm = theta_hat_pois_lognorm,
.RNG.name = "base::Wichmann-Hill",
.RNG.seed = 789)
)
# ---------------------------------------------------
# RUN JAGS MODEL
# ---------------------------------------------------
jags_model_pois_lognorm <- jags.model(
textConnection(model_code_pois_lognorm),
data = itamtplcost_input,
inits = inits_pois_lognorm,
n.chains = 3,
n.adapt = 1000
)
samples_pois_lognorm <- coda.samples(
jags_model_pois_lognorm,
variable.names = c("mu_pois_lognorm",
"tau_pois_lognorm",
"theta_pois_lognorm"),
n.iter = 30000
)
# Diagnostics & summaries
params <- c("mu_pois_lognorm", "tau_pois_lognorm", "theta_pois_lognorm")
# Gelman-Rubin diagnostics
for (param in params) {
gelman.plot(samples_pois_lognorm[, param], xlab = "", ylab = "")
}
gelman.diag(samples_pois_lognorm, autoburnin = FALSE)
mu_hat_pois_lognorm
sigma_hat_pois_lognorm
theta_hat_pois_lognorm
tau_hat_pois_lognorm <- 1/sigma_hat_pois_lognorm^2
tau_hat_pois_lognorm
# ---------------------------------------------------
# RUN JAGS MODEL
# ---------------------------------------------------
jags_model_pois_lognorm <- jags.model(
textConnection(model_code_pois_lognorm),
data = itamtplcost_input,
inits = inits_pois_lognorm,
n.chains = 3,
n.adapt = 10000
)
samples_pois_lognorm <- coda.samples(
jags_model_pois_lognorm,
variable.names = c("mu_pois_lognorm",
"tau_pois_lognorm",
"theta_pois_lognorm"),
n.iter = 30000
)
# Autocorrelation diagnostics
autocorr.diag(samples_pois_lognorm[, "mu_pois_lognorm"], lags = 1:10)
autocorr.diag(samples_pois_lognorm[, "tau_pois_lognorm"], lags = 1:10)
autocorr.diag(samples_pois_lognorm[, "theta_pois_lognorm"], lags = 1:10)
# Autocorrelation diagnostics
autocorr.plot(samples_pois_lognorm[, "mu_pois_lognorm"], ask=FALSE)
autocorr.plot(samples_pois_lognorm[, "tau_pois_lognorm"], ask=FALSE)
autocorr.plot(samples_pois_lognorm[, "theta_pois_lognorm"], ask=FALSE)
# ---------------------------------------------------
# RUN JAGS MODEL
# ---------------------------------------------------
jags_model_pois_lognorm <- jags.model(
textConnection(model_code_pois_lognorm),
data = itamtplcost_input,
inits = inits_pois_lognorm,
n.chains = 3,
n.adapt = 10000
)
samples_pois_lognorm <- coda.samples(
jags_model_pois_lognorm,
variable.names = c("mu_pois_lognorm",
"tau_pois_lognorm",
"theta_pois_lognorm"),
n.iter = 30000
)
# Autocorrelation diagnostics
autocorr.plot(samples_pois_lognorm[, "mu_pois_lognorm"], ask=FALSE)
autocorr.diag(samples_pois_lognorm[, "mu_pois_lognorm"], lags = 1:10)
autocorr.diag(samples_pois_lognorm[, "tau_pois_lognorm"], lags = 1:10)
autocorr.diag(samples_pois_lognorm[, "theta_pois_lognorm"], lags = 1:10)
# ---------------------------------------------------
# RUN JAGS MODEL
# ---------------------------------------------------
jags_model_pois_lognorm <- jags.model(
textConnection(model_code_pois_lognorm),
data = itamtplcost_input,
inits = inits_pois_lognorm,
n.chains = 3,
n.adapt = 10000
)
samples_pois_lognorm <- coda.samples(
jags_model_pois_lognorm,
variable.names = c("mu_pois_lognorm",
"tau_pois_lognorm",
"theta_pois_lognorm"),
n.iter = 300000,
thin = 10
)
# Autocorrelation diagnostics
autocorr.plot(samples_pois_lognorm[, "mu_pois_lognorm"], ask=FALSE)
# Autocorrelation diagnostics
autocorr.plot(samples_pois_lognorm[, "mu_pois_lognorm"], ask=FALSE)
autocorr.plot(samples_pois_lognorm[, "tau_pois_lognorm"], ask=FALSE)
autocorr.plot(samples_pois_lognorm[, "theta_pois_lognorm"], ask=FALSE)
# Traceplots
traceplot(samples_pois_lognorm[, params], main="", xlab="")
# Posterior summary
summary(samples_pois_lognorm)
# Density plots
plot(density(as.matrix(samples_pois_lognorm[, "mu_pois_lognorm"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_pois_lognorm[, "tau_pois_lognorm"])), main="", xlab="", ylab="")
plot(density(as.matrix(samples_pois_lognorm[, "theta_pois_lognorm"])), main="", xlab="", ylab="")
# Lognormal expected value calculation
lognormal_ev <- function(mu, tau) {
sigma2 <- 1 / tau
exp(mu + sigma2 / 2)
}
posterior_pois_lognorm <- as.matrix(samples_pois_lognorm)
expected_y_pois_lognorm <- lognormal_ev(posterior_pois_lognorm[, "mu_pois_lognorm"],
posterior_pois_lognorm[, "tau_pois_lognorm"])
mean(expected_y_pois_lognorm)
sd(expected_y_pois_lognorm)
quantile(expected_y_pois_lognorm, c(0.025, 0.5, 0.975), na.rm = TRUE)
plot(density(expected_y_pois_lognorm, na.rm=TRUE), main="", xlab="", ylab="")
# ---------------------------------------------------
# PLOT: Empirical vs Posterior Lognormal CDF
# ---------------------------------------------------
y_obs <- itamtplcost_input$y
mu_pois_lognorm_post_mean <- mean(posterior_pois_lognorm[, "mu_pois_lognorm"])
sigma_pois_lognorm_post_mean <- mean(1 / sqrt(posterior_pois_lognorm[, "tau_pois_lognorm"]))
lognormal_cdf <- function(x, mu, sigma) {
pnorm(log(x), mean = mu, sd = sigma)
}
plot(
ecdf(y_obs),
col = "blue",
main = "Empirical vs Posterior Lognormal CDF",
xlab = "y values",
ylab = "CDF",
lwd = 2
)
x_vals <- seq(min(y_obs), max(y_obs), length.out = 500)
lines(x_vals,
lognormal_cdf(x_vals, mu_pois_lognorm_post_mean, sigma_pois_lognorm_post_mean),
col = "red", lwd = 2, lty = 2)
legend("bottomright",
legend = c("Empirical CDF",
sprintf("Lognormal(%.3f, %.3f) CDF",
mu_pois_lognorm_post_mean,
sigma_pois_lognorm_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
plot(
ecdf(y_obs),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2
)
x_vals <- seq(min(y_obs), max(y_obs), length.out = 500)
lines(x_vals,
lognormal_cdf(x_vals, mu_pois_lognorm_post_mean, sigma_pois_lognorm_post_mean),
col = "red", lwd = 2, lty = 2)
legend("bottomright",
legend = c("Empirical CDF",
sprintf("Lognormal(%.3f, %.3f) CDF",
mu_pois_lognorm_post_mean,
sigma_pois_lognorm_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
theta_pois_lognorm_post_mean <- mean(posterior_pois_lognorm[, "theta_pois_lognorm"])
# Plot empirical CDF for Poisson counts
plot(
ecdf(n),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2,
xlim = c(min(n), max(n) + 3)  # extend x-axis for visibility
)
n
# ---------------------------------------------------
# PLOT 2: EMPIRICAL VS POSTERIOR POISSON CDF
# ---------------------------------------------------
n <- itamtplcost_input$n
theta_pois_lognorm_post_mean <- mean(posterior_pois_lognorm[, "theta_pois_lognorm"])
# Plot empirical CDF for Poisson counts
plot(
ecdf(n),
col = "blue",
main = "",
xlab = "",
ylab = "",
lwd = 2,
xlim = c(min(n), max(n) + 3)  # extend x-axis for visibility
)
# Overlay theoretical Poisson CDF
x_vals <- min(n):(max(n) + 3)
lines(x_vals, ppois(x_vals, lambda = theta_pois_lognorm_post_mean),
col = "red", lwd = 2, lty = 2, type = "s")  # 's' for step
theta_pois_lognorm_post_mean
legend("bottomright",
legend = c("Empirical CDF", "Poisson(28.628) CDF"),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
legend("bottomright",
legend = c("Empirical CDF",
sprintf("Lognormal(%.3f, %.3f) CDF",
mu_pois_lognorm_post_mean,
sigma_pois_lognorm_post_mean)),
col = c("blue", "red"), lty = c(1, 2), lwd = 2)
lognorm_predictions <- numeric(1000)
uniform_samples <- runif(1000)
mu_pois_lognorm_posterior <- posterior_pois_lognorm[, "mu_pois_lognorm"]
sigma_pois_lognorm_posterior <- 1 / sqrt(posterior_pois_lognorm[, "tau_pois_lognorm"])
for (i in seq_along(uniform_samples)) {
U <- uniform_samples[i]
normal_samples <- qnorm(U, mean = mu_pois_lognorm_posterior, sd = sigma_pois_lognorm_posterior)
lognorm_samples <- exp(normal_samples)
lognorm_predictions[i] <- mean(lognorm_samples)
}
plot(density(lognorm_predictions, na.rm = TRUE), main = "", xlab = "", ylab = "")
set.seed(123)
# Simulation parameters
n_sim <- 1000
theta_pois_lognorm_posterior <- posterior_pois_lognorm[, "theta_pois_lognorm"]
# Simulate number of claims
uniform_poisson <- runif(n_sim)
poisson_results <- numeric(n_sim)
for (i in seq_along(uniform_poisson)) {
U <- uniform_poisson[i]
cat("Simulation", i, "\n")
poisson_samples <- numeric(length(theta_pois_lognorm_posterior))
for (j in seq_along(theta_pois_lognorm_posterior)) {
poisson_samples[j] <- pois(theta_pois_lognorm_posterior[j], U)
}
poisson_results[i] <- round(mean(poisson_samples))
}
# Function to simulate Poisson samples
pois <- function(lambda, U) {
p <- exp(-lambda)
F <- p
n <- 0
while (U > F) {
n <- n + 1
p <- p * lambda / n
F <- F + p
}
return(n)
}
# ---------------------------------------------------
# PREDICTIONS: Poisson-Lognormal Distribution
# ---------------------------------------------------
set.seed(123)
# Simulation parameters
n_sim <- 1000
theta_pois_lognorm_posterior <- posterior_pois_lognorm[, "theta_pois_lognorm"]
# Simulate number of claims
uniform_poisson <- runif(n_sim)
poisson_results <- numeric(n_sim)
for (i in seq_along(uniform_poisson)) {
U <- uniform_poisson[i]
cat("Simulation", i, "\n")
poisson_samples <- numeric(length(theta_pois_lognorm_posterior))
for (j in seq_along(theta_pois_lognorm_posterior)) {
poisson_samples[j] <- pois(theta_pois_lognorm_posterior[j], U)
}
poisson_results[i] <- round(mean(poisson_samples))
}
# Compare empirical vs simulated claim counts
summary(itamtplcost_input$n) # Empirical
summary(poisson_results) # Fitted
# Simulate aggregate claims
aggregate_claims_pois_lognorm <- numeric(length(poisson_results))
for (i in seq_along(poisson_results)) {
n <- poisson_results[i]
lognorm_samples <- numeric(n)
uniform_lognorm <- runif(n)
for (j in seq_along(uniform_lognorm)) {
U <- uniform_lognorm[j]
normal_samples <- qnorm(U, mean = mu_pois_lognorm_posterior, sd = sigma_pois_lognorm_posterior)
lognorm_samples[j] <- mean(exp(normal_samples))
}
aggregate_claims_pois_lognorm[i] <- sum(lognorm_samples)
}
# Compare to empirical aggregate claim distribution
help <- itamtplcost %>%
group_by(year) %>%
summarise(sum = sum(claim_amount), .groups = "drop")
summary(help$sum) # Empirical
summary(aggregate_claims_pois_lognorm) # Fitted
# ---------------------------------------------------
# Fit & Plot Distributions to Aggregate Claims
# ---------------------------------------------------
# Estimate distribution parameters via moment matching
mean_S <- mean(aggregate_claims_pois_lognorm)
var_S <- var(aggregate_claims_pois_lognorm)
gamma_shape <- mean_S^2 / var_S
gamma_rate <- mean_S / var_S
sigma2_ln <- log(1 + var_S / mean_S^2)
mu_ln <- log(mean_S) - sigma2_ln / 2
normal_mean <- mean_S
normal_sd <- sqrt(var_S)
# Define support for density plots
x_vals <- seq(min(aggregate_claims_pois_lognorm), max(aggregate_claims_pois_lognorm), length.out = 1000)
gamma_densities <- dgamma(x_vals, shape = gamma_shape, rate = gamma_rate)
lognorm_densities <- dlnorm(x_vals, meanlog = mu_ln, sdlog = sqrt(sigma2_ln))
normal_densities <- dnorm(x_vals, mean = normal_mean, sd = normal_sd)
hist_density <- hist(aggregate_claims_pois_lognorm, plot = FALSE, probability = TRUE)$density
max_y <- max(gamma_densities, lognorm_densities, normal_densities, hist_density)
# Plotting
hist(aggregate_claims_pois_lognorm, probability = TRUE, breaks = 100,
col = "gray90", border = "white", main = "",
xlab = "", ylab = "", ylim = c(0, max_y * 1.05))
curve(dgamma(x, shape = gamma_shape, rate = gamma_rate), col = "blue", lwd = 2, add = TRUE)
curve(dlnorm(x, meanlog = mu_ln, sdlog = sqrt(sigma2_ln)), col = "green", lwd = 2, add = TRUE)
curve(dnorm(x, mean = normal_mean, sd = normal_sd), col = "red", lwd = 2, add = TRUE)
legend("topright", legend = c("Gamma", "Lognormal", "Normal"),
col = c("blue", "green", "red"), lwd = 2)
# Summary statistics
median(aggregate_claims_pois_lognorm)
quantile(aggregate_claims_pois_lognorm, probs = c(0.90, 0.95, 0.99))
max(aggregate_claims_pois_lognorm)
gamma_shape
gamma_rate
